<html>
	<head>
		 <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
		
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/xterm/3.14.5/xterm.min.css" integrity="sha512-iLYuqv+v/P4u9erpk+KM83Ioe/l7SEmr7wB6g+Kg1qmEit8EShDKnKtLHlv2QXUp7GGJhmqDI+1PhJYLTsfb8w==" crossorigin="anonymous" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/xterm/3.14.5/xterm.min.js" integrity="sha512-2PRgAav8Os8vLcOAh1gSaDoNLe1fAyq8/G3QSdyjFFD+OqNjLeHE/8q4+S4MEZgPsuo+itHopj+hJvqS8XUQ8A==" crossorigin="anonymous"></script>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
	</head>

	<body>
		<div class="container">
			<div class="row" style="background-color:black;color:grey">
                <div class="col-md-8 col-sm-12">
                    <div id="term"></div>
                </div>

                <div class="col-md-4 col-sm-12">
                    <a class="btn" data-toggle="collapse" href="#debug">
						<div><h5>Variables...</h5></div>
					</a>

					<div id="debug" class="collapse"></div>
                </div>
			</div>

            <div class="row">
                <div class="col-sm-12">
                    <h3>Programming DOPE</h3>
                </div>
            </div>

            <div class="row">
                <div class="col-sm-12">
                    <h3>What is DOPE?</h3>

                    <p>
                        DOPE(Dartmouth Oversimplified Programming Experiment) was the direct predecesor to BASIC. The language was developed by John Kemeny in 1962. Throught the 50s and 60s Kemeny and his collegue, Thomas Kurtz, had been trying to find a way to teach non-science majors about computers. DOPE was the latest attempt, an experimental language designed for the novice programmer. It was used in a single classin '62. This wasn't a failure, it was by desing. Hence the 'E' in DOPE. Despite it's short life DOPE was an important proving ground for ideas that would come to shape BASIC. And for years it has remained somewhat enigmatic... at least until now!
                    </p>

                    <p>
                        I host a podcast called Advent of Computing that covers, what else, the history of the computer. Recently I was gathering information for an episode on BASIC when I ran into a strange hole in the sources. Kemeny and Kurtz mention DOPE in interviews, papers, and books. There is even a small example program tucked away in an article written by Kurtz. But besides the mentions and a few lines of code there isn't all that much out there about DOPE. That kind of missing information doesn't sit well with me, so I set about fixing it. I was able to track down the origional paper describing DOPE in Dartmouth's archive and get a copy digitized. As far as I'm concerned that paper, simply titled "Dartmouth Oversimplified Programming Experiment", is the authoritative source on the language.
                    </p>

                    <p>
                        Once I tracked down the details my next step was clear: preservation and resurrection. As near as I can tell DOPE was only used for one term at Dartmouth, and I haven't been able to find the original compiler for the language. With direct emulation out of the question my only optionw as to write my own implementation of the long-dead language. So I present to you DOPE-20, a mostly accurate implementation of language. I intend this as a way to recreate a bit of lost history. DOPE was never built for seriosu programming, but by examining the language we can get deeper insight into the development of BASIC. Think of it as Jurassic Park, but the dinasaur here is comprised of bits and bytes.
                    </p>

                    <p>
                        DOPE-20 is relatively accurate to the source material, but there are some major caveats that bear mentioning. As of today I am the world's preeminent DOPE expert, the DOPE lord if you like, so I've taken some librties with my implementation. Most of these were done to make it more accessible to a wider audience, something that would be in line with the language's original goals. The biggest change is the interface. The machine that ran DOPE, an LGP-30, did have a teletype terminal so it's likeley DOPE was typed into the machine. However, I've expanded things out to a more DTSS/BASIC like command line interface. This probably isn't period accurate, but I think it's a reasonable departure. I also have no evidence that DOPE used a line number based editing interface. Given the time period I doubt there was really any text editing interface.
                    </p>

                    <p>
                        I've also done away with a lot of the restrictions of the original language. Per the spec a DOPE program can only be 99 lines long, variables have hard upper and lower values, and to get around that scientific notation can be used. All of those limitations were in place due to the small capacity of the LGP-30 comptuer. The spirit behind DOPE(and yes, BASIC too) is that arbitrary limitations are a hinderance, so I decided to stick to that mantra. Another large change is that DOPE-20 is interpreted, not compiled. The 1962 implementation used a compiler, and Kemeny and Kurtz are in general very anti-interpreter. I chose implement DOPE-20 in an interpreted enviroment so it's a little more accessible. The entire interpreter is written in JavaScript, that way curious users can just load up a webpage and check out the language. It woudln't be very hard to write a DOPE compiler, but then you'd have to be a little more tech savvy to experience the language. Once again, I think this is in keeping with the spirit of DOPE as a language for non-programmers.
                    </p>
                </div>
            </div>
        </div>
	</body>

	<script>
		var term = new Terminal();
		term.open(document.getElementById("term"));
		term.write("DOPE-20\r\nReady\r\n\r\n");

		var vars = {
			"E": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			"F": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			"G": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
			"H": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
		};

		var ops = {
			"+": {
                checks: ["csv", "csv", "sv"],
                run: function(args, mask){ //Add
				    var a = getValue(args[0], mask[0]);
				    var b = getValue(args[1], mask[1]);

				    setValue(args[2], mask[2], a + b);
			    }
            },
			"-": {
                checks: ["csv", "csv", "sv"],
                run: function(args, mask){ //Subtract
				    var a = getValue(args[0], mask[0]);
				    var b = getValue(args[1], mask[1]);

    				setValue(args[2], mask[2], a - b);
                }
			},
			".": {
                checks: ["csv", "csv", "sv"],
                run: function(args, mask){ //Multiply
				    var a = getValue(args[0], mask[0]);
				    var b = getValue(args[1], mask[1]);

				    setValue(args[2], mask[2], a * b);
                }
			},
			"/": {
                checks: ["csv", "csv", "sv"],
                run: function(args, mask){ //Divide
				    var a = getValue(args[0], mask[0]);
				    var b = getValue(args[1], mask[1]);

				    setValue(args[2], mask[2], a / b);
                }
			},
			";": {
                checks: ["csv", "sv"],
                run: function(args, mask){ //Set value
				    var a = getValue(args[0], mask[0]);
				    setValue(args[1], mask[1], a);
			    }
            },
			"SQR": {
                checks: ["csv", "sv"],
                run: function(args, mask){
				    var a = getValue(args[0], mask[0]);
				    setValue(args[1], mask[1], Math.sqrt(a));	
                }
			},
			"EXP": {
                checks: ["csv", "sv"],
                run: function(args, mask){
				    var a = getValue(args[0], mask[0]);
				    setValue(args[1], mask[1], Math.exp(a));	
                }
			},
			"LOG": {
                checks: ["csv", "sv"],
                run: function(args, mask){
				    var a = getValue(args[0], mask[0]);
				    setValue(args[1], mask[1], Math.log(a));	
                }
			},
			"SIN": {
                checks: ["csv", "sv"],
                run: function(args, mask){
				    var a = getValue(args[0], mask[0]);
				    setValue(args[1], mask[1], Math.sin(a));	
                }
			},
			"C": {
                checks: ["csv", "csv", "csv", "csv", "csv"],
                run: function(args, mask){ //Conditional jump
				    var a = getValue(args[0], mask[0]);
				    var b = getValue(args[1], mask[1]);

				    var l1 = getValue(args[2], mask[2]);
				    var l2 = getValue(args[3], mask[3]);
				    var l3 = getValue(args[4], mask[4]);

				    if(a > b){
    					return l1;
				    }else if(a == b){
    					return l2;
	    			}else if(a < b){
		    			return l3;
			    	}
                }
			},
			"T": {
                checks: ["csv"],
                run: function(args, mask){ //jump To line
				    var a = getValue(args[0], mask[0]);
				    return a;
                }
			},
			"P": {
                checks: ["csv"],
                run: function(args, mask){ //Print value
				    var a = getValue(args[0], mask[0]);
				    output(a);
                }
			},
			"A": {
                checks: ["l"],
                run: function(args, mask){ //Print label, aka string literal
				    var a = getValue(args[0], mask[0]);
				    output(a);
                }
			},
			"N": {
                checks: [],
                run: function(args, mask){ //Print newline
				    output("\r\n");
                }
			},
			"J": {
                checks: ["sv"],
                run: function(args, mask){ //Take keyboard input => var
				    /*
                    term.write(" -->> ");
				    input();
				    setValue(args[0], mask[0], parseFloat(buffer));
                    */

                    var n = prompt("Input A Number");
                    setValue(args[0], mask[0], parseFloat(n));
                }
			},
			"Z": {
                checks: ["sv", "csv", "csv"],
                run: function(args, mask, num){ //Attempt at simple for loop
				    var a = args[0];
				    var b = getValue(args[1], mask[1]);
				    var c = getValue(args[2], mask[2]);

    				if(loops.length == 0 || loops[loops.length - 1] != num){ //Is this loop new?
	    				setValue(a, mask[0], b); //Set out iterator to the initial value
		    			loops.push(num); //Save over the line number of the loop
			    	}else{ //We are iterating
				    	setValue(a, mask[0], getValue(a, mask[0]) + 1); //We can only go up, them's the rules

					    if(vars[a] >= c){ //Is this the last iteration?
						    loops.pop(); //Remove us from the loop list
					    }
				    }
                }
			},
			"E": {
                checks: [],
                run: function(args, mask){ //End of loop block
				    if(loops.length > 0){
    					return loops[loops.length - 1];
	    			}
		    	}
            }
		};

        var maskNames = {
            "l": "LABEL",
            "c": "CONSTANT",
            "s": "SCALAR",
            "v": "VECTOR"
        };

		var lines = [
			,
			"; 10 B",
			"Z A 1 10",
			"P B",
			"- B 1 B",
			"N",
			"E",
			"A BOOM!",
			"F"
		];

		var loops = [];
		var sep = " "; //Token seporator, will eventually switch to '

		term.write(" > ");

		var buff = ""; //Global buffer

		controlLoop(); //I hate everything about how JS works...

		async function controlLoop(){
			while(true){
				await input();
				console.log(buff);
				handle(buff);
			}
		}

		function handle(buff){
			//Deal with commands. This isn't in the spec but it's my implementation...
			//	...so let's get creative
			if(buff.match(/^[1-9]/)){ //We have a line number, load it in
				var ts = buff.split(sep);
				lines[ts.shift()] = ts.join(sep);
			}else if(buff.toUpperCase() == "LIST"){
				term.write(lines.map(function(d, i){
					return i + " " + d;
				}).join("\r\n") + "\r\n");
			}else if(buff.toUpperCase() == "RUN"){
				run();
			}else if(buff.toUpperCase() == "NEW"){
				lines = [];
			}else{
				var n = runLine(0, buff);
			}

			term.write("\r\n > ");
		}

		async function input(cb){
			buff = "";

			var {data} = await new Promise(resolve => {
				var keyHandler = term.onKey(function(d){
					var key = d.key;

					if(key.charCodeAt(0) == 13){
						term.write("\r\n");
						keyHandler.dispose();
						resolve(buff);
						return buff;
					}else if(key.charCodeAt(0) == 127){ //It's a backspace
						if(buff.length > 0){
							buff = buff.slice(0, -1);
							term.write('\x1b[D \x1b[D');
						}
					}else{
						term.write(key);
						buff += key;
					}
				});
			});

			return data;
		}

		function run(){
			var n = 1;

			while(lines[n] != "F" && n < lines.length){ //Run until FINAL or no more lines
				console.log("Running Line: " + n);
				var next = runLine(n, lines[n]);
					
				if(next == -1){
					break;
				}

				n = next;
			}
		}

		function getValue(token, mask){	
			if(mask == "c"){ //Deal with const value
				return parseFloat(token);
			}else if(mask == "s"){ //Grab a scalar var
				return vars[token];
			}else if(mask == "v"){ //Grab a vector... kinda gross...
				var [t, i] = token.split(/[\[\]]/);

				iMask = makeMask([i])[0];
				if(iMask == "s"){
					i = getValue(i, iMask);
				}

				return vars[t][i];
			}else if(mask == "l"){
				return token;
			}
		}

		function setValue(token, mask, val){
			if(mask == "s"){ //Set a scalar
				vars[token] = val;
			}else if(mask == "v"){ //Then we have a vector
				var [t, i] = token.split(/[\[\]]/);

				iMask = makeMask([i])[0];
				if(iMask == "s"){
					i = getValue(i, iMask);
				}

				vars[t][i] = val;
			}
		}

		function output(d){
			term.write("" + d);
		}

		function showVars(){
			$("#debug").html("<ul>");

			for(const [key, value] of Object.entries(vars)){
				if(!key.match(/^[EFGH]$/)){
					$("#debug").append("<li>" + key + " -> " + value + "</li>");
				}
			}

			["E", "F", "G", "H"].forEach(function(i){
				$("#debug").append("<li>" + i + " -> " + vars[i].join(",") + "</li>");
			});

			$("#debug").append("</ul>");
		}

		function runLine(num, line){
			//Split to tokens, should be by ' but using space for now
			var t = line.split(sep);
			var op = t.shift();

			if(ops[op]){ //Is this a valid operation?
				//Lets make a mask...
				var mask = makeMask(t);
				console.log(mask);

                //Do syntax check here!
                var checks = ops[op].checks;

                //Do we have the right number of args?
                if(t.length != checks.length){
                    error(op + " ACCEPTS " + checks.length + " ARGS", num);
                    return -1;
                }

                //Do we have the right kind of args?
                for(var i = 0; i < checks.length; i++){
                    var regex = new RegExp("^[" + checks[i] + "]$");

                    if(!mask[i].match(regex)){
                        error("ARG " + (i + 1) + " TO " + op + " CANNOT BE A " + maskNames[mask[i]], num);
                        return -1;
                    }
                }

				var nextLine = ops[op].run(t, mask, num);
				showVars();

				if(!nextLine || typeof nextLine !== "number"){
					nextLine = num + 1;
					
					//Deal with non-continous line numbers... :(
				}else{
					console.log("Jumping to: " + nextLine);
				}

				return nextLine;
			}else{
				//Throw an error
				error();
			}
		}

		function error(msg = null, line = null){
			term.write("SYNTAX ERROR" + (line ? ", LINE " + line : "") + (msg ? ": " + msg : ""));
		}

		function makeMask(args){
			return args.map(function(t){
				if(t.match(/^[A-Z][0-9]?$/)){
					return "s"; //It's a avriable, ops will understand
				}else if(t.match(/^[0-9\.\-\+]/)){
					return "c"; //It's a constant... don't use restrictions for now
				}else if(t.match(/^[EFGH]\[.*\]$/)){
					return "v" //It's a vector
				}else{
					return "l"; //It's a label
				}
			});
		}
	</script>
</html>
